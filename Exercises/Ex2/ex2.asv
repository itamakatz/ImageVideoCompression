% a = [ 25 0 0 -13 11 0 7]
% equivalent_vector(a)
exp_golomb_test()
% benchmark()

% =========== B: ZigZag =========== %

% Tested
function zigZagArray = zigzag(mat)
	ind = reshape(1:numel(mat), size(mat));   %# indices of elements
	ind = fliplr(spdiags(fliplr(ind)));       %# get the anti-diagonals
	ind(:,1:2:end) = flipud(ind(:,1:2:end));  %# reverse order of odd columns
	ind(ind==0) = [];                         %# keep non-zero indices
	zigZagArray = mat(ind);
end

% Tested
function mat = izigzag(zigZagArray, imSize)
	M = 1:length(zigZagArray);
	M = reshape(M, imSize);
	indices = zigzag(M);
	mat = zeros(imSize);
	for i = 1:length(indices)
		index = indices(i);
		mat(fix((index-1)/imSize(2))+1,rem(index-1,imSize(2))+1) = zigZagArray(i);
	end
	mat = reshape(mat.', imSize);
end

% Tested
function success = zigzag_test()
	M = randi(100, [5 6])
	zigZagArray = zigzag(M);
	restoreM = izigzag(zigZagArray, size(M))
	
	success = isequal(M, restoreM)
	assert(success)
end

% =========== E: ZigZag =========== %
% =========== B: Blocking =========== %

% Tested
function structMat = splitMat2Struct(mat, blockSizeArray)
	if(size(blockSizeArray) == [1,1])
		blockSizeArray = [blockSizeArray, blockSizeArray];
	end 

	matSize = size(mat);

	reshapedMat = permute(reshape(mat, blockSizeArray(1), matSize(1) / blockSizeArray(1), blockSizeArray(2), matSize(2) / blockSizeArray(2)), [2, 4, 1, 3]);
	structMat(matSize(1)/blockSizeArray(1),matSize(2)/blockSizeArray(2)).submat = zeros(size(reshapedMat(1,1,:,:)), class(size(reshapedMat(1,1,:,:))));
	structMat(matSize(1)/blockSizeArray(1),matSize(2)/blockSizeArray(2)).origin = [0,0];
	for i = 1:matSize(1)/blockSizeArray(1)
		for j = 1:matSize(2)/blockSizeArray(2)
			bla = reshapedMat(i,j,:,:);
			structMat(i,j).submat = reshape(bla, blockSizeArray(1), blockSizeArray(2));
			structMat(i,j).origin = [1 + (i-1)*blockSizeArray(1), 1 + (j-1)*blockSizeArray(2)];
		end
	end
end

% Tested
function mat = structMat2Mat(structMat)
	structMatSize = size(structMat);
	blockSize = [size(structMat(1,1).submat,1), size(structMat(1,1).submat,2)];
	mat = zeros([structMatSize(1)*blockSize(1), structMatSize(2)*blockSize(2)], class(structMat(1,1).submat));
	for i = 1:structMatSize(1)
		for j = 1:structMatSize(2)
			mat(structMat(i,j).origin(1):structMat(i,j).origin(1)+blockSize(1)-1,...
				structMat(i,j).origin(2):structMat(i,j).origin(2)+blockSize(2)-1) = structMat(i,j).submat;
		end
	end
end

% =========== E: Blocking =========== %
% =========== B: Normalization =========== %

% Tested
function new_val = normalize(val)
	assert(val >= 0 && val <= 255)
	new_val = val/256 - 0.5;
end

% Tested
function new_val = denormalize(val)
	assert(val >= -0.5 && val < 0.5)
	new_val = (val + 0.5)*256;
end

% Tested
function success = normalize_test()
	val = randi([0,255]);
	restore_val = denormalize(normalize(val));
	success = isequal(restore_val, val);
	assert(success)

	val = 0;
	restore_val = denormalize(normalize(val));
	success = isequal(restore_val, val);
	assert(success)

	val = 255;
	restore_val = denormalize(normalize(val));
	success = isequal(restore_val, val);
	assert(success)
end

% =========== E: Normalization =========== %
% =========== B: MSE / PSNR / Rate =========== %

% Tested
function error_val = MSE(im1,im2)
	error_val = immse(im1,im2);
end
% Tested
function val = PSNR(im1,ref)
	val = psnr(im1,ref);
end
% Tested
function rate = image_rate(image_path)
	imInfo = imfinfo(image_path);
	rate = imInfo.FileSize / (imInfo.BitDepth * imInfo.Width * imInfo.Height);
end

% =========== S: MSE / PSNR / Rate =========== %

% =========== B: Benchmark =========== %

% Tested
function benchmark()
	im = imread('Mona-Lisa.bmp');
	psnr_array = zeros([1,101]);
	rate_array = zeros([1,101]);
	for i = 0:100
		imwrite(im,'Mona-Lisa.jpg','jpg','quality',i);
		imCompressed = imread('Mona-Lisa.jpg');
		psnr_array(i+1) = PSNR(imCompressed,im);
		% bmp_rate = image_rate('Mona-Lisa.bmp')
		rate_array(i+1) =  image_rate('Mona-Lisa.jpg');
	end
	plot(rate_array,psnr_array)
	xlabel('Rate')
	ylabel('PSNR')
end

% =========== E: Benchmark =========== %
% =========== B: 4 =========== %

% =========== E: 4 =========== %

% =========== B: Equivalent Vector =========== %

function new_vec = equivalent_vector(vec,k1,k2,k3)
	integers = [];
	runs = [];
	tmp = ones(size(vec));
	tmp(vec~=0) = 0;
	last_zero = find(tmp,1,'last');
	fist_time = true;
	for i = 1:numel(vec)
		if(vec(i) == 0 && ~fist_time)
			runs(end) = runs(end) + 1;
		else
			fist_time = false;
			runs = [runs 0];
			integers = [integers vec(i)];
		end
	end

	assert(runs(end) == 0);
	runs = runs(1:end-1);
	assert(runs(end) ~= 0);
	new_vec = {last_zero, integers, runs};
end

% =========== E: Equivalent Vector =========== %

% =========== B: Golomb-Rice =========== %

function golomb_rice()

end

% =========== E: Golomb-Rice =========== %

% =========== B: Exp-Golomb =========== %

% Tested
function codeBits = exp_golomb(num, k)
	num = num+2.^k-1;
	numCharArray = dec2bin(num+1);
	len = length(numCharArray)-1;
	uncutCode = [(zeros(1,len)+'0') numCharArray];
	codeBits = uncutCode(k+1:end);
end

% Tested
function num = exp_golomb_inverse(codeBits, k)
	codeBitsFull = [zeros(1,k)+'0', codeBits];
	cutIndex = find(codeBitsFull-'0', 1, 'first');
	codeBitsCut = codeBitsFull(cutIndex:end);
	num = bi2de(codeBitsCut-'0','left-msb')-1;
	num = num-2.^k+1 ;
end

function success = exp_golomb_test()
	for index = 1:100
		a = randi([-1000,1000]);
		k = randi([0,7]);
		b = exp_golomb(a,k)
		c = exp_golomb_inverse(b,k)
		success = isequal(a,c);
		assert(success);
	end
end
% =========== E: Exp-Golomb =========== %vec